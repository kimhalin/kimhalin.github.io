---
layout: post
title: 2022-08-26 TIL
# description: >
#   Howdy! This is an example blog post that shows several types of HTML content supported in this theme.
sitemap: false
hide_last_modified: true
---
2022-08-26 TIL






## JPA 기본편

### 영속성 컨텍스트 - 엔티티를 영구 저장하는 환경

- 객체를 생성한 상태 - 비영속
- 객체를 생성한 후에 저장한 상태 - 영속 (em.persist(생성한 객체))
    
    ❗️ 영속 상태가 된다고 해서 DB에 쿼리가 날라가는 것이 아니다.
    
- 엔티티를 영속성 컨텍스트에서 분리 - 준영속
- 객체를 삭제한 상태 - 삭제

→ 어플리케이션이랑 DB 사이에 뭔가 하나 더 있다 라고 이해하면 쉬움

### 1차 캐시

find()로 조회할 때, 1차 캐시에서 먼저 조회를 해보고 있으면 바로 값을 반환, 

없으면, DB에서 조회해서 1차 캐시에 저장 후 값을 반환한다.

→ 막 성능 이점을 얻을 수 있진 않다. 비즈니스가 엄청 복잡할 때는 도움될 수도 ..?

### 영속 엔티티의 동일성 보장

같은 엔티티를 조회했을 때 같은 객체로 인식해서 == 연산이 true가 나온다

### 트랜잭션을 지원하는 쓰기 지연

em.persist 할 때 바로 쿼리를 보내지 않고, 쓰기 지연 SQL 저장소에 따로 저장 → 트랜잭션을 commit하는 시점에 실제 쿼리가 날라간다.

**🔦  버퍼링** 

batch_size만큼 모아놨다가 한 번에 DB에 보내도록 하는 것

### 엔티티 수정 변경 감지

수정할 때에는 persist를 실행하지 않아도 된다. JPA의 목적은 자바 컬렉션을 다루듯이 DB를 다루는 것!!

그냥 값만 바꾸고 커밋하면 된다.

엔티티랑 스냅샷을 비교해 값이 만약 바뀌어 있다면? 쓰기 지연 SQL 저장소에 update쿼리를 저장해 놓는ㄴ다.

### 플러시

영속성 컨텍스트의 변경내용을 데이터베이스에 동기화(쓰기 지연 SQL 저장소에 있는 내용 DB에 반영, 변경 감지)

- em.flush() - 직접 플러시
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출

### 준영속 상태

- em.detach(entity) → 특정 엔티티만 준영속 상태로 전환
- em.clear() → 영속성 컨텍스트를 완전히 초기화
- em.close()  → 영속성 컨텍스트를 종료