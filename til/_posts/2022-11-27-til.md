---
layout: post
title: 2022-11-27 TIL
# description: >
#   Howdy! This is an example blog post that shows several types of HTML content supported in this theme.
sitemap: false
hide_last_modified: true
---
2022-11-27 TIL


 
 





## 카프카 구조

### 카프카 클러스터

메시지를 저장하는 저장소 → 여러 개의 브로커로 구성됨

브로커가 메시지를 나눠서 저장하고 있다.

### 주키퍼 클러스터(앙상블)

카프카 클러스트들을 관리

### 프로듀서

카프카 클러스터에 메시지를 넣는 역할

### 컨슈머

카프카 클러스터에서 메시지를 읽어와 필요한 처리

## 토픽과 파티션

<aside>
💡 **프로듀서 & 컨슈머**

**프로듀서:** 이 메시지를 이 토픽에 저장해줘~
**컨슈머:** 이 토픽의 파티션을 읽을게~

</aside>

### 토픽

메시지를 구분하는 단위, 즉 폴더 개념

하나의 토픽 안에는 여러 파티션이 존재

### 파티션

메시지를 저장하는 물리적인 파일, 추가만 가능한 **append-only** 파일

- offset → 각 메시지 저장 위치
- 프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가
- 컨슈머는 오프셋 기준으로 순서대로 읽는다
    
    ‼️ 여기서 주의할 점은 컨슈머가 데이터를 읽어도 파티션에서 삭제되지 않는다.
    

<aside>
💡 프로듀서는 어떻게 어떤 파티션에 메시지를 저장할까?

프로듀서가 **라운드로빈으로 돌아가면서 저장**을 하거나, **키의 해시값을 이용해서 저장할 파티션 지정**

프로듀서는 메시지를 저장할 때 토픽과 함께 키를 들고 오기도 한다. 키가 있다면? 키의 해시값 이용!

</aside>

**하나의 파티션은 컨슈머그룹의 한 개 컨슈머만 연결 가능하다**

topic1 - p0 → 그룹 A의 1, 그룹 B의 1 ⇒ **가능**

topic1 - p0 → 그룹 A의 1, 그룹 A의 1 ⇒ **불가능**

하나의 컨슈머그룹 기준으로 파티션의 메시지는 순서대로 처리된다.

## 프로듀서

- 레코드를 send한다
- send된 메시지를 byte 배열로 변환하여 Partitioner(파티션 결정 역할)에게 넘긴다
- Partitioner는 버퍼에 레코드를 넣는데, 이때 버퍼 안에서는 여러 메시지를 묶어서 배치로 관리를 한다.
- Sender는 버퍼에서 순서대로 가져와 브로커에 보낸다.

### Sender

Sender와 send()는 각각 별도의 쓰레드로 동작해서 상관없이 할 일 알아서 한다.

따라서 Sender는 배치가 찼는지 여부에 상관없이 차례대로 브로커에 전송한다.

- batch.size: 하나의 배치 크기
- linger.ms: 전송 대기 시간 (기본값 0)
    
    대기 시간이 없다면, Sender가 배치를 바로 전송하고
    
    대기 시간을 주면, 그 시간 만큼 기다렸다 배치를 전송하니 배치가 찰 때까지 살짝 기다렸다가 전송한다.
    

### 전송 보장 & ack

- ack = 0
    
    서버 응답을 기다리지 않음
    
    전송 보장도 zero
    
- ack = 1
    
    파티션의 리더에 저장되면 응답 받음
    
    리더 장애시 메시지 유실 가능
    
- ack = all
    
    모든 리플리카에 저장되면 응답 받음
    
- min.insync.replicas ⇒ 브로커 옵션
    - 프로듀서 ack 옵션이 all일 때 저장에 성공했다고 응답할 수 있는 동기화된 리플리카 최소 개수
    
    <aside>
    💡 만약 min.insync.replicas 값이 2일 경우
    
    리더 브로커에 저장하고, 그 팔로워 중 한 개에 저장하면 성공 응답 가능
    
    </aside>
    

### 에러 유형

- 전송 과정에서 실패
    - 전송 타임 아웃
    - 리더 다운에 의한 새 리더 선출 진행 중
    - 브로커 설정 메시지 크기 한도 초과
- 전송 전에 실패
    - 직렬화 실패, 프로듀서 자체 요청 크기 제한 초과
    - 프로듀서 버퍼가 차서 기다린 시간이 최대 대기 시간 초과

## 컨슈머

컨슈머 개수가 파티션 개수보다 많이 생기면 안된다

왜? 바로 같은 컨슈머 그룹의 컨슈머는 같은 파티션을 담당할 수 없기 떄문

### 컨슈머 설정

- fetch.min.bytes: 조회시 브로커가 전송할 최소 데이터 크기
- fetch.max.wait.ms: 데이터가 최소 크기가 될 떄까지 기다릴 시간
    
    브로커가 리턴할 때까지 대기하는 시간 !
    
- max.partition.fetch.bytes: 파티션 당 서버가 리턴할 수 있는 최대 크기

### 자동/수동 커밋

- enable.auto.commit 설정:
    
    true: 일정 주기로 컨슈머가 읽은 오프셋을 커밋(기본값)
    
    false: 수동 커밋
    

### 재처리와 순서

- 동일 메시지 조회 가능성
    
    → 일시적 커밋 실패, 리밸런스 등에 의해 발생
    
- 멱등성 고려

### 하트비트, 세션 타임아웃

- 컨슈머와 브로커는 컨슈머가 전송하는 하트비트를 통해 연결을 유지
    
    만약 일정 시간 컨슈머의 **하트비트 전송이 없다면** 브로커는 컨슈머를 그룹에서 빼고 **리밸런스** 진행


> 💡 **편리해 보이지만 실무에서 사용할 수 없다**
<br>
→ 아예 중간 객체를 하나 만들어야 함
<br>
예를 들어, 주문내역이면 Member와 Product만 있는 것이 아니라 주문 수량, 날짜 이런 것들이 필요한데, 오로지 매핑만 가능하기 때문에 다른 column을 추가할 수 없다

따라서 왼쪽 객체와 다대일, 오른쪽 객체와 다대일인 객체를 하나 추가하자

